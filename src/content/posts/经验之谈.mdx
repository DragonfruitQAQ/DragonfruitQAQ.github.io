---
title: 或许值得记录的经验
published: 2025-09-18T00:00:00.000Z
updated: 2025-11-21T00:00:00.000Z
description: 工作过程中遇到的一些问题以及如何解决的
image: "/images/scenery4.jpg"
tags:
  - Unity
  - RenderDoc
  - 其他
category: 工作记录
draft: false
---
import Collapse from "../../components/mdx/Collapse.astro";
import Diff from "../../components/mdx/Diff.astro";
import Tabs from "../../components/mdx/Tabs.astro";
import QAItem from "../../components/mdx/QAItem.astro";
import Video from "../../components/mdx/Video.astro";

## 1. 一些功能的实现

1. 热区功能：分了数个区域，每个球员分配一串序号决定热区还是冷区，踩到相应区域变色。

<Video src="/videos/hotZoneVisualization.mp4" title="热区功能演示" loop={true} />

对Mesh的不同区域顶点用顶点色进行区分。后续，顶点着色器根据顶点色确认区域索引。最后像素着色器根据索引决定返回的颜色。
最终返回的颜色包括：透明，热区亮红色，热区被选中暗红，冷区亮蓝色，冷区被选中暗蓝色。

2. 简单切换场景功能：

<Video src="/videos/switchSceneSimple.mp4" title="简要切换场景功能演示" loop={true} />

有关这个功能，其实一开始实现起来颇为方便，只需调配好特定的资源路径，分别在脚本中获取替换即可（当然需要注意美术资产的规范性，如果不规范的话需要获取特定`旋转缩放`信息）。

<QAItem
  question="然而如果物体有更改怎么处理？"
  answer="较为合理的做法是重新获取物体的路径并且保存为资产，后续如果有物体修改的话，重新获取路径刷新资产即可。"
/>

## 2.调试修复BUG经验

1. RenderMeshInstanced 和 DrawMeshInstancedIndirect 均使用到了 `gpu instance` 技术，可以高效渲染大量网格。前者使用方便，后者则将计算任务交给gpu追求极致性能。

<Tabs tabs={[
  { id: "tab1", label: "RenderMeshInstanced" },
  { id: "tab2", label: "DrawMeshInstancedIndirect" }
]}>
<div slot="tab1">
  从 __CPU__ 端准备好所有需要渲染的实例数据（例如每个实例的位置、旋转、缩放矩阵，
  或者包含这些信息的自定义结构体数组），然后一次性提交给 GPU 进行渲染。
</div>
<div slot="tab2">
  渲染参数（尤其是要渲染的实例数量）不是由 CPU 直接指定的，而是从一个 GPU 上
 的计算缓冲区（Compute Buffer）中读取的。这个过程是“间接的”（Indirect），因此得名。
</div>
</Tabs>

2. 复制纹理遇到的bug

<QAItem
  question="在从Texture2D拷贝图像到Texture2DArray特定层的时候会遇到：graphics.copytexture source and destination have different master texture limits. source 1, destination 0"
  answer="原因：使用了Mipmap的Texture2D主纹理可能有所限制，而Array没有这一设定。使用sourceTex.ignoreMipmapLimit = true;即可解决"
/>

3. 调试程序错误时遇到打了断点但是程序运行不到断点的情况：一般是用了某个未被赋值的变量，仔细查看报错信息(喂给AI)


4. 垃圾回收gc

代码写的不好，每帧初始化一些结构体就会触发这个问题。注意`打印信息`中如果有字符串结构体，也可能导致gc，并且一时半会儿找不到gc的来源。（unity profiler中可以查看gc）

5. pc移动端表现不一致

<Diff
  l="/images/audienceWithBUG.jpg"
  r="/images/audienceNoBUG.jpg"
  leftAlt="实例缺失"
  rightAlt="正常情况"
/>

观众渲染在使用`间接渲染`的时候会出现移动端表现与pc端不一致的情况，从表现上来看，在不同LOD层级过渡的过程中似乎有实例缺失，
但是经过逐步调试发现buffer中的参数表现均属正常。最后发现是vulkan、metal平台与DX和OpenGL平台对于Instance的DrawCall处理差异的问题
：前两者会合并批次，而后两者会依据cpu端调用而不合并批次。
需要下列代码fix问题
```astro
#if !defined(SHADER_API_METAL) || ！defined(SHADER_API_VULKAN)
  uint index = unity_InstanceID + _ArgsBuffer[_ArgsOffset];
#else
  uint index = unity_InstanceID;
#endif
```



6. RenderDoc可以调试compute shader，打开pipeline 窗口，选择特定的线程即可。

7. 关于Compute shader中颜色空间的问题：
先上链接：https://zhuanlan.zhihu.com/p/14250635909

在选定项目属于Linear（大多数项目都会选这个，便于shader计算）时，shader采样srgb贴图或者inspector上的颜色
时，会进行转换，将伽马空间颜色转为线性后计算，最终输出时，再进行一次转换，转换到伽马空间显示。

- compute shader采样与普通shader相同，但是当compute shader写入srgb贴图的时候，`不会进伽马矫正`，所以需要手动矫正数据。

8. Unity项目有个设置是优化Mesh顶点数据，如果勾选该项那么顶点数据中未被使用到的顶点数据可能会被优化。

例如compute shader中传递顶点数据，用到buffer的时候需要注意传入的顶点数据格式。

9. 当游戏运行到静态场景的时候，可以设置管线传递绘制好的RT，减少性能消耗。

基本没用，游戏中的场景很少静止（镜头会动）。