---
title: 观众渲染中的工作记录
published: 2025-11-14T15:50:00.000Z
updated: 2024-01-11T00:00:00.000Z
description: 记录我在观众渲染中完成的事情
image: "/images/cover1.jpeg"
tags:
  - Audience
  - Unity
  - compute shader
category: 工作记录
draft: false
---
import Collapse from "../../components/mdx/Collapse.astro";
import Diff from "../../components/mdx/Diff.astro";
import Tabs from "../../components/mdx/Tabs.astro";
import QAItem from "../../components/QAItem.astro";

# 大规模观众渲染

## 1. 整体效果

<Diff
  l="/images/image_home_noAA.jpg"
  r="/images/image_home_TAA.jpg"
  leftAlt="未抗锯齿"
  rightAlt="TAA"
/>

## 2. 引言
 
大规模观众渲染移动端来说是一个不小的挑战
- 效果方面：观众配色需要适配30+场馆，实例数量在6000以上，观众动作尽可能多样且不重复，光照需要层次感。
- 性能方面：8Gen3要求120帧，15分钟不降频，最终达到了十分钟稳110帧左右, 后续稳定100帧。

后续我从工作流程展开，具体可以记录一下我在工作中完成的事项。

## 3. 总体流程
观众渲染的整个流程主要分为：观众动作响应系统设计->烘焙顶点动画->根据纹理绘制
不同lod观众->根据场馆给纹理数组上色->进一步整体性能优化
#### a. 动作响应系统
篮球场的观众需要跟着场上是否得分而做出反应，因为动作资产并未提前设计，所以是先给到资源，然后再设计状态机的。如图分为坐姿休闲，半躺过渡，正坐，坐姿鼓掌，站立，站立鼓掌，起身等等动作。
根据给到的资源，我简单设计了过渡状态。将所有动作全部放入一个animator中，然后复制生成多个animator，每个可以做一点差异化，然后随机设定参数决定当前的animator做什么动作。
#### b. 烘焙顶点动画
首先unity开启gpu skinning选项进行gpu蒙皮，会将骨骼网格中的顶点从模型空间变换到世界空间。我们需要记录的是模型空间的顶点，使用compute shader每个线程记录一个顶点，随后保存在纹理中。
项目对观众总共应用了8个animator，分别对应一张纹理，组合起来形成纹理数组便于compute shader进行操作。
获取顶点信息的方式：
```astro
skinnedMeshRenderer.vertexBufferTarget = Graphics.Target.Raw;
```
最终我们需要获取的是变换后的模型空间顶点数据，所以注意在compute shader中传入相应矩阵进行转换。
#### c. 绘制不同lod观众
每次DrawCall传入到gpu的网格需要保持一致，为了限制DrawCall数量，我们合并了同一lod层级的Mesh用于绘制。

-   **LOD0 (最高精度):**
    -  **男:** 包含 `人物` 和 `帽子`。
    -   **女:** 包含 `人物`, `帽子`, `头发1`, 和 `头发2`。
-   **LOD1 & LOD2 (中/低精度):**
    -   **男 & 女:** 只包含 `人物`。

进一步减少DrawCall，将男女网格简单合并顶点，用于绘制。绘制过程中根据对应贴图数量，以及Instance的ID来共同决定这个
实例是哪一类观众（一共5正常男，1带帽男，1带帽女，1单马尾女，1短发女）。
- 绘制过程中，确定好了目前实例是哪一类观众后，需要丢弃多余顶点。剩余的顶点，按照`排列方式`以及传入的`偏移数组`决定查找
顶点动画纹理中的特定顶点范围，保证每个实例仅代表一个观众。
#### d. 根据场馆对纹理上色
由于观众所需的场馆众多，而且需要实时切换颜色。最开始的方案是贴图本身不变，随后传入特定场馆对应的
颜色数据进行叠加。但是颜色数据占用cbuffer不少，最初的版本根据下面在着色器中修改传入`变量`上色：
```astro
float4 shoesColor[6];
float4 pantColor[6];
float4 clothColor0[12];
float4 clothColor1[12];  
float4 hatColor[6];
  ```
一个想法是将上完色的纹理直接保存下来，后续使用直接采样即可。可是30+场馆，每个场馆需要36张纹理（代表至少36个不同的观众），`存储开销`过大。
后续的方案是游戏运行过程中使用compute shader直接给贴图纹理上色并且保存。总共保存36张压缩过的贴图构成的纹理数组，占用内存1.5MB，
在可接受范围内。compute shader中除了基础的读取保存贴图外，还考虑到美术那边不想调节过多色彩，每个场馆只给到了特定数量的色彩
需要重新排列这些色彩重新给贴图的特定部分上色。

## 4. 性能优化
除了实现过程中的一些优化以外，在部署完成后还进行了额外的性能优化：
- 观众做的比较紧密切规整，可以使用一个包围盒包住，处在包围盒上的观众以更高层次的LOD
显示，包围盒内部的观众实例则以低层次的LOD实现即可。
- 光照部分，因为是使用的`Graphics.RenderMeshInstance`这个接口，每帧cpu均需发送实例的数据
（例如合并后的位置数据）到gpu，随后进行绘制。我们可以考虑在一个区域内的观众使用近似的lightprobe来进行漫反射的渲染。


## 5. 后续展望

前面提到使用`Graphics.RenderMeshInstance`这个接口是cpu每帧发送数据到gpu，后续使用`Graphics.RenderMeshInstanceIndirect
`进行绘制可以进一步提升性能。使用后者可以在8GEN3手机上实现约4W实例的100帧。大神的链接和Demo如下：https://github.com/ellioman/Indirect-Rendering-With-Compute-Shaders

## 6. 额外经验小结

<Tabs
  tabs={[
    { id: "tab1", label: "GC垃圾回收" },
    { id: "tab2", label: "网格合并" },
    { id: "tab3", label: "多余顶点处理" }, 
    { id: "tab4", label: "移动端兼容" },
    { id: "tab5", label: "多余顶点处理2" }
  ]}
  defaultTab="tab1"
>
  <div slot="tab1">
     千万不要在类似Update()函数中初始化一些结构体，会触发垃圾回收机制，造成大量的带宽损耗。
  </div>

  <div slot="tab2">
    骨骼网格的合并最好让美术将所有网格的骨骼保持一致，并刷好权重，当然略有差别是没问题的，可选择`骨骼最多`的网格的那套骨骼作为最终合并后的网格骨骼即可。
    在应对权重的时候需要查找骨骼的名字，使得顶点中的骨骼权重与`骨骼序号`对应。合并需要注意`顶点顺序，法线，UV，切线`。最后应用选中的骨骼的`bindpose`。
    
    ——最终效果是一套骨骼可以正确的驱动合并后的所有顶点
  </div>

  <div slot="tab3">
    在渲染网格的时候，多余的顶点部分如果不需要渲染的话可以简单的将其裁切空间`位置加1000`，顶点会被硬件裁切掉，如果额外调用`discard`的话性能不如前者。
  </div>

  <div slot="tab4">
    computeshader中定义类似：
    ```astro
    static const uint turnedID[9] = { 0, 1, 2, 3, 4, 5, 5, 0, 2};
    ```
    打包到移动端后可能无法使用
  </div>

  <div slot="tab5">
    在渲染网格的时候，多余的顶点部分如果不需要渲染的话可以简单的将其裁切空间`位置加1000`，顶点会被硬件裁切掉，如果额外调用`discard`的话性能不如前者。
  </div>
</Tabs>
