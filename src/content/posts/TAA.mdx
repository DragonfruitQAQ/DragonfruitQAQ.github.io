---
title: TAA 抗锯齿
published: 2024-01-11T00:00:00.000Z
updated: 2024-01-11T00:00:00.000Z
description: 展示 TAA 中的原理及实现
image: "/images/cover1.jpeg"
tags:
  - TAA
  - Unity
  - motion vector
category: 实践记录
draft: false
---
import Collapse from "../../components/mdx/Collapse.astro";
import Diff from "../../components/mdx/Diff.astro";
import Tabs from "../../components/mdx/Tabs.astro";
import QAItem from "../../components/mdx/QAItem.astro";
import VideoDiff from "../../components/mdx/VideoDiff.astro";

# Unity 实现 TAA

## 1. 效果对比

### 静态

<Diff
  l="/images/NoTAA.jpg"
  r="/images/TAA.jpg"
  leftAlt="未抗锯齿"
  rightAlt="TAA"
/>

### 动态

<VideoDiff
  l="/videos/NoTAA.mp4"
  r="/videos/TAAwithMotionVector.mp4"
  leftAlt="没有TAA"
  rightAlt="TAA"
/>

## 2. 引言

锯齿是图形中一个常见的现象，目前也有非常多的抗锯齿技术，最有名的莫过于DLSS（深度学习超采样），
其中DLSS2的技术原理是基于Temporal Anti-Anliasing (TAA)的。想要了解这些技术首先要了解锯齿产生的原因：

![锯齿产生原因](/images/sampleForPixel.jpg)

上图所示，当每一个像素有一个采样点的时候，这个像素的颜色完全取决于采样点采样是否在三角形内部，如果采样点在三角形内部，那么就显示三角形颜色，否则就显示背景。这样，锯齿就产生了。我们可以总结，锯齿产生的本质原因是采样率过低导致的失真，那么最简单的抗锯齿方法就是增加采样率。
SSAA超采样抗锯齿就是这样做的，增加像素中采样点的数量，随后根据采样点的分布混合而得最终的像素颜色。
TAA时域抗锯齿，原理上来说与SSAA相似，只不过SSAA是相当于渲染两倍大小的图像随后缩小成原始图像，
而TAA则是将其余的采样点分布到其他帧上，结合了历史帧和当前帧进行混合抗锯齿。
  
静态场景下的TAA很容易理解，但是在游戏方面，动态场景才是主要的。包括摄像机移动旋转，物体移动，uv动画等等等等。那么就涉及如何找到与当前帧的像素对应的上一帧的像素的问题，以及有些像素在历史帧更不找不到对应的，那么就需要在合理范围内拒绝掉可能出现的历史帧颜色。

## 3. 实现TAA的主要部分

- __`TemporalAAFeature` (ScriptableRendererFeature)__:

  - 作为 URP 的 Renderer Feature 入口，负责创建和配置 TAA 相关的 Render Pass。
  - 管理 TAA 的各项设置 (`TAASettings`)，如混合比例、抖动强度、锐化参数、Filter 类型等。
  - 根据 Unity 版本差异，管理 Motion Vector Pass 和 Depth Copy Pass 的创建。

- __`TAAJitterPass` (ScriptableRenderPass)__:

  - 负责计算和应用相机的投影矩阵抖动（Jitter）。
  - 使用 Halton 序列生成抖动偏移量，并在每一帧对投影矩阵进行微小的偏移，这是 TAA 能够通过多帧信息重建超采样图像的基础。
  - 将抖动后的矩阵应用到当前帧的渲染中，并设置全局 Shader 变量 `_JitterMatrix`。

- __`TAARenderPass` (ScriptableRenderPass)__:

  - 执行实际的 TAA 后处理 Shader (`TempoalAA.shader`)。
  - 负责历史帧纹理 (`_historyTexture` / `accumTexture`) 的维护和 ping-pong 读写。
  - 处理当前帧颜色与历史帧颜色的混合。
  - 根据设置执行锐化处理。

__Motion Vectors (运动向量) 支持__:

- 为了解决动态场景下的重影（Ghosting）问题，实现了自定义的 Motion Vector 计算。

- __`CustomMotionVectorPass`__: 负责渲染 Motion Vector Texture。它包含三个部分：

  - __Camera Motion__: 计算相机移动产生的像素速度 (`TAACameraMotionVectors.shader`)。
  - __Object Motion__: 计算动态物体移动产生的像素速度 (`TAAObjectMotionVectors.shader`)。
  - __FOV Object Motion__: 专门处理特殊 FOV 物体（开局站着的五个哥们）的 Motion Vector (`TAAFovObjectMotionVectors.shader`)。

- __`CustomMotionVectorRendering` & `CustomPreviousFrameData`__: 用于管理和存储上一帧的 ViewProjection 矩阵，以便正确计算当前帧相对于上一帧的运动。

## 4. 后续shader中实现的各种优化

- __Filter 采样__:

  - 支持 __Bicubic Filter__ (`_TAA_UseBicubicFilter`): 在采样历史帧时使用双三次插值（5-tap 近似），比标准的双线性插值更清晰，能减少历史帧累积带来的模糊。
  - 支持 __9-Tap / 5-Tap Sampling__: 在统计当前帧邻域颜色时，可选择 9 采样点或 5 采样点模式，平衡性能与质量。

- __YCoCg 色彩空间__: 所有的混合和 Clamping 操作都在 YCoCg 空间进行（`RGBToYCoCg` / `YCoCgToRGB`）。YCoCg 空间将亮度（Luma）和色度分离，在此空间进行混合比 RGB 空间更符合人眼感知，能减少色偏。

- __Perceptual Space Lerp__ (`_TAA_LerpAtPerceptualSpace`): 混合时并非直接线性插值，而是根据亮度进行加权，使得在暗部和亮部的混合更加自然。

- __锐化 (Sharpening)__: TAA 本质上会带来模糊，因此在 TAA 后包含了一个锐化 Pass（或集成在 TAA Pass 中），使用简单的 3x3 卷积核进行锐化，补偿 TAA 带来的细节损失。

__Dilation (膨胀)__ (`_TAA_UseDilation`): 用于增强边缘的稳定性。

## 5. 展望

性能开销对于手机来说不小，如果省略很多优化的话，画面瑕疵也不少。对于体育游戏来说，似乎锯齿比模糊更易接受一些。（即便是SSAA也会有边缘模糊的情况）
后续没有实际在项目的移动端部署TAA。                                                                                                       |
