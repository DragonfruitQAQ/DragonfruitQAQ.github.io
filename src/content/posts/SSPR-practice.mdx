---
title: SSPR（屏幕空间平面反射）实践
published: 2025-08-14T00:00:00.000Z
updated: 2025-08-20T00:00:00.000Z
description: 在实际项目中应用SSPR，以及一些trick优化
image: "/images/scenery1.jpg"
tags:
  - Unity
  - SSPR
  - 屏幕空间
category: 实践记录
draft: false
---
import Collapse from "../../components/mdx/Collapse.astro";
import Diff from "../../components/mdx/Diff.astro";
import Tabs from "../../components/mdx/Tabs.astro";
import QAItem from "../../components/mdx/QAItem.astro";


# Screen Space Planar Reflection (SSPR)
## 1. 最终效果

<Diff
  l="/images/SSPR_最终效果.png"
  r="/images/SSPR_未添加反射.png"
  leftAlt="添加地板反射"
  rightAlt="未添加地板反射"
/>
SSPR在篮球场景中的应用效果如上，左侧为加了反射，右侧未添加，可以拖动分割条观察。



主要做了什么事情？
1. 根据原始`屏幕纹理`以及`深度贴图`，对每个屏幕纹理的像素查询其世界空间位置，然后直接将其世界空间位置按照水平面取反。
2. 取反后的世界空间位置再转换到屏幕空间纹理上，将原始像素填充到映射后的屏幕空间位置，这样就得到`反射贴图`。
3. 最后用这个反射贴图近似预滤波环境贴图来渲染球场内的地板（不够物理）。


## 2. 原理部分
关于SSPR的原理其实相对简单和有趣。这里首先贴出一些链接。
1. 首先贴出应该是原始的技术分享链接：
https://remi-genin.github.io/posts/screen-space-planar-reflections-in-ghost-recon-wildlands/
2. 然后是知乎大佬的实践和理解：
https://zhuanlan.zhihu.com/p/651134124

然后说下我在实践中的一些理解，尽可能用简单的话语来解释：
1. 物体的反射在直观上其实感觉到是`物体的光`射向平面然后`反弹`到相机内部形成反射，当然在不怎么追求准确性的条件下，我们可以将物体的光直接取代`反射的光`。
2. 尽管可以取代，我们仍需要确定反射光的具体位置。实现上，我们可以使用 compute shader 处理每一个像素。具体是：根据深度图获取这个像素的世界空间位置，然后将位置的y值直接取反，
重新投影回屏幕获得一个屏幕坐标，即`反射UV`,将当前像素位置的颜色（屏幕纹理）直接复制填入反射UV所在的像素（反射贴图）即可。
3. 后续使用这张反射贴图的时候直接使用平面的屏幕uv去采样这张反射贴图即可。
4. 但是这样存在一个关键性的问题：多个实际在水平面上方的屏幕像素可能映射到反射贴图的相同位置，那么选择哪个像素作为`反射光`呢？
换句话说：想象一下，高远处的一个像素A和近低处的一个像素B，经过反射计算后，可能它们的反射UV是完全相同的。此时，那么选择哪个像素的颜色作为`反射光`呢？我们会选择距离平面近的

幸运的是，在多个线程同时处理像素的时候，我们可以用到`InterlockedMin`：一个原子操作，它能保证在多线程同时访问某个地址时，只有一个线程能成功写入。它会比较地址中原有的值和当前线程要写入的值，只保留较小的那一个。
于是，我们将当前像素的二维坐标(x, y)编码成一个整数hash,通常y坐标放在高位，这样y值小的（更靠近屏幕下方/更近的）像素，其hash值也更小。
HashBuffer是一个和反射图一样大的缓冲区，用于记录“胜出者”的信息。
- 结果：经过所有线程的“竞争”，`_HashBuffer[ridx]` 中最终会存下所有试图写入该位置的像素中，`hash` 值最小的那个像素的 `hash`。通常这意味着离观察者最近的那个像素的反射“胜出”了，后续我们将胜出的线程（像素）赋值到反射贴图上即可。

<QAItem
  question="为什么链接原文使用的是InterlockedMax，而我们使用的是InterlockedMin呢？"
  answer="对于 DX, Metal, Vulkan，UNITY_UV_STARTS_AT_TOP，我们需要选择最上方的像素，即id.y小的那个像素。对于OpenGL，uv 是从左下角开始的，我们需要选择id.y较大的那个。"
/>

## 3.反射相机和SSPR结合
SSPR最大的缺陷无疑是屏幕空间，在屏幕空间外一切信息都无法用于反射。然而使用类似反射相机的方法提前将一些存在于屏幕空间外的物体倒置在水平面下，然后提前绘制在反射贴图上就可以某种程度上解决这个问题。

![中间瑕疵_SSPR](/images/中间瑕疵_SSPR.jpg)

图中蓝色箭头所指灯带即可反射，但是在实践过程中遇到了新的问题，即使广告牌已经倒置提前绘制到反射贴图了，图中黄色位置还是没有正确显示反射。经过调试发现原因仍旧是屏幕空间外的信息没有正确传递。

具体是：如果球员巴特勒不在广告牌的位置，那么正常来说，`观众`的像素和`广告牌`的像素会竞争，最后广告牌的像素会赢，随后覆盖反射贴图可以正确显示。但是现在巴特勒将广告牌的像素挡住了，于是观众的像素没有竞争直接映射到反射贴图位置，随后覆盖了原本倒置的广告牌产生了渲染错误。


<Collapse title="解决方法">
  原因是没有像素和观众的像素竞争了，那么我们可以重新渲染深度到反射纹理的a通道，随后让a通道的对应像素和观众像素竞争即可。
  具体是在渲染倒置物体的pass中添加一个深度渲染的pass，渲染特定的（广告牌）的深度，然后这个深度的像素会赢得竞争，
  ```astro
  float reflectXdepth = _SSPRReflectionTexture[id.xy].a;
  float2 ruvPre = GetReflectUV(uv, reflectXdepth);
  uint2 ridxPre = ruvPre * _SSPRReflectionSize.xy;
  InterlockedMin(_HashBuffer[ridxPre], hash);
  ```

    
  然后当hash值与最终赢得的hash值不一致的时候不要去填充反射纹理，
  ```astro
  if (hash != _HashBuffer[ridx])
  {
      return;
  }
  ```
  这样`观众`的像素就不会覆盖到提前绘制的倒置物体了。
</Collapse>
## 4.结语
光线追踪无疑是实现反射的好方法，但在某些项目中SSPR也有用武之地。只考虑静态镜面反射的话，IBL可以充分使用。
我们也可以参考预滤波环境贴图的使用方法，使用粗糙度采样反射贴图的不同mipmap层级，进一步优化反射效果。当然需要一定开销是每一帧使用`cmd.GenerateMips(mReflectionTex);`
